/* tslint:disable */
/* eslint-disable */
/**
 * Subtiter API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  HTTPValidationError,
  SubtitleApplication,
  SubtitleConfigurationUI,
} from '../models/index';
import {
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    SubtitleApplicationFromJSON,
    SubtitleApplicationToJSON,
    SubtitleConfigurationUIFromJSON,
    SubtitleConfigurationUIToJSON,
} from '../models/index';

export interface GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPostRequest {
    videoId: string;
    requestBody: { [key: string]: any; };
}

export interface GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost0Request {
    videoId: string;
    requestBody: { [key: string]: any; };
}

export interface GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPostRequest {
    videoId: string;
    subtitleApplication: SubtitleApplication;
}

export interface GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost0Request {
    videoId: string;
    subtitleApplication: SubtitleApplication;
}

export interface GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPostRequest {
    videoId: string;
    requestBody: { [key: string]: any; };
}

export interface GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost0Request {
    videoId: string;
    requestBody: { [key: string]: any; };
}

export interface GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGetRequest {
    videoId: string;
}

export interface GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet0Request {
    videoId: string;
}

export interface ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGetRequest {
    index: string;
    videoId: string;
    userId: string;
}

export interface ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet0Request {
    index: string;
    videoId: string;
    userId: string;
}

/**
 * 
 */
export class UserSubtitlingApi extends runtime.BaseAPI {

    /**
     * Generate shorts from a video.
     * Generate Shorts Simulate
     */
    async generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPostRaw(requestParameters: GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/simulate/generate-subtitling/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Shorts Simulate
     */
    async generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost(requestParameters: GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate shorts from a video.
     * Generate Shorts Simulate
     */
    async generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost_1Raw(requestParameters: GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost_1().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost_1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/simulate/generate-subtitling/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Shorts Simulate
     */
    async generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost_1(requestParameters: GenerateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateShortsSimulateApiV1UserSubtitlingSimulateGenerateSubtitlingVideoIdPost_1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling
     */
    async generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPostRaw(requestParameters: GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost().'
            );
        }

        if (requestParameters['subtitleApplication'] == null) {
            throw new runtime.RequiredError(
                'subtitleApplication',
                'Required parameter "subtitleApplication" was null or undefined when calling generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/generate-subtitling/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubtitleApplicationToJSON(requestParameters['subtitleApplication']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling
     */
    async generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost(requestParameters: GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling
     */
    async generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost_2Raw(requestParameters: GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost_2().'
            );
        }

        if (requestParameters['subtitleApplication'] == null) {
            throw new runtime.RequiredError(
                'subtitleApplication',
                'Required parameter "subtitleApplication" was null or undefined when calling generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost_2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/generate-subtitling/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SubtitleApplicationToJSON(requestParameters['subtitleApplication']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling
     */
    async generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost_2(requestParameters: GenerateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateSubtitlingApiV1UserSubtitlingGenerateSubtitlingVideoIdPost_2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling Fargate
     */
    async generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPostRaw(requestParameters: GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/generate-subtitling-task/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling Fargate
     */
    async generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost(requestParameters: GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling Fargate
     */
    async generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost_3Raw(requestParameters: GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost_3().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost_3().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/user-subtitling/generate-subtitling-task/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Generate shorts from a video.
     * Generate Subtitling Fargate
     */
    async generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost_3(requestParameters: GenerateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.generateSubtitlingFargateApiV1UserSubtitlingGenerateSubtitlingTaskVideoIdPost_3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Generated Shorts Info
     */
    async getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGetRaw(requestParameters: GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SubtitleConfigurationUI>>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/user-subtitling/generated-subtitling-info/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubtitleConfigurationUIFromJSON));
    }

    /**
     * Get Generated Shorts Info
     */
    async getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet(requestParameters: GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SubtitleConfigurationUI>> {
        const response = await this.getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Generated Shorts Info
     */
    async getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet_4Raw(requestParameters: GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SubtitleConfigurationUI>>> {
        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet_4().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/user-subtitling/generated-subtitling-info/{video_id}`.replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SubtitleConfigurationUIFromJSON));
    }

    /**
     * Get Generated Shorts Info
     */
    async getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet_4(requestParameters: GetGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SubtitleConfigurationUI>> {
        const response = await this.getGeneratedShortsInfoApiV1UserSubtitlingGeneratedSubtitlingInfoVideoIdGet_4Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Serves a video file for video player consumption. Supports proper MIME types, range requests, and file streaming for video playback.
     * Serve Subtitling Video File
     */
    async serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGetRaw(requestParameters: ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet().'
            );
        }

        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/user-subtitling/serve/{user_id}/{video_id}/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))).replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Serves a video file for video player consumption. Supports proper MIME types, range requests, and file streaming for video playback.
     * Serve Subtitling Video File
     */
    async serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet(requestParameters: ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Serves a video file for video player consumption. Supports proper MIME types, range requests, and file streaming for video playback.
     * Serve Subtitling Video File
     */
    async serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5Raw(requestParameters: ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['index'] == null) {
            throw new runtime.RequiredError(
                'index',
                'Required parameter "index" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5().'
            );
        }

        if (requestParameters['videoId'] == null) {
            throw new runtime.RequiredError(
                'videoId',
                'Required parameter "videoId" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5().'
            );
        }

        if (requestParameters['userId'] == null) {
            throw new runtime.RequiredError(
                'userId',
                'Required parameter "userId" was null or undefined when calling serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/user-subtitling/serve/{user_id}/{video_id}/{index}`.replace(`{${"index"}}`, encodeURIComponent(String(requestParameters['index']))).replace(`{${"video_id"}}`, encodeURIComponent(String(requestParameters['videoId']))).replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters['userId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Serves a video file for video player consumption. Supports proper MIME types, range requests, and file streaming for video playback.
     * Serve Subtitling Video File
     */
    async serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5(requestParameters: ServeSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.serveSubtitlingVideoFileApiV1UserSubtitlingServeUserIdVideoIdIndexGet_5Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
